{"version":3,"file":"static/webpack/static/development/pages/_app.js.e1e3b75c69e83a3fc23c.hot-update.js","sources":["webpack:///./src/services/game.service.ts"],"sourcesContent":["import { Board, BoardShift } from '@2048/types/game';\n\nexport function generateEmptyBoard(\n  width: number,\n  height: number,\n  value: number = 0\n): Board {\n  return [...Array(height)].map(_ => new Array(width).fill(value));\n}\n\nexport function isValidBoard(\n  width: number,\n  height: number,\n  board: Board\n): boolean {\n  const widthValid = board.length === width;\n  const heightValid = board.every(r => r.length === height);\n  return widthValid && heightValid;\n}\n\nfunction merge(\n  getPoint: (coord: number) => number,\n  setPoint: (coord: number, value: number) => void,\n  from: number,\n  to: number\n): void {\n  setPoint(to, getPoint(from) + getPoint(to));\n  setPoint(from, 0);\n}\n\nfunction mergeFirst(\n  getPoint: (coord: number) => number,\n  setPoint: (coord: number, value: number) => void,\n  length: number\n): boolean {\n  for (let i = 0; i < length - 1; i++) {\n    if (getPoint(i) !== 0 && getPoint(i) === getPoint(i + 1)) {\n      merge(getPoint, setPoint, i, i + 1);\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction push(\n  getPoint: (coord: number) => number,\n  setPoint: (coord: number, value: number) => void,\n  length: number,\n  startIdx: number\n): boolean {\n  let curr = startIdx + 1;\n  if (curr >= length || getPoint(curr) !== 0) return false;\n  while (curr < length - 1 && getPoint(curr + 1) === 0) {\n    curr++;\n  }\n  merge(getPoint, setPoint, startIdx, curr);\n  return true;\n}\n\nexport function propagateLine(\n  getPoint: (coord: number) => number,\n  setPoint: (coord: number, value: number) => void,\n  length: number\n): boolean {\n  let moved = false;\n  for (let i = length - 1; i >= 0; i--) {\n    if (getPoint(i) !== 0) {\n      moved = push(getPoint, setPoint, length, i) || moved;\n    }\n  }\n  moved = mergeFirst(getPoint, setPoint, length) || moved;\n  return moved;\n}\n\nexport function getHeight(board: Board) {\n  if (board.length === 0) {\n    return 0;\n  } else {\n    return board[0].length;\n  }\n}\n\nexport function getWidth(board: Board) {\n  return board.length;\n}\n\nexport function propagateGrid(\n  getLine: (lineIdx: number) => (coord: number) => number,\n  setLine: (lineIdx: number) => (coord: number, value: number) => void,\n  numLines: number,\n  lineLength: number\n): boolean {\n  let moved = false;\n  for (let i = 0; i < numLines; i++) {\n    moved = propagateLine(getLine(i), setLine(i), lineLength) || moved;\n  }\n  return moved;\n}\n\nfunction getPropagateLineFunc(\n  board: Board,\n  shift: 'up' | 'down' | 'left' | 'right'\n): {\n  getLine: (lineIdx: number) => (coord: number) => number;\n  setLine: (lineIdx: number) => (coord: number, value: number) => void;\n  numLines: number;\n  lineLength: number;\n} {\n  const height = getHeight(board);\n  const width = getWidth(board);\n  switch (shift) {\n    case 'up':\n      return {\n        getLine: (lineIdx: number) => (coord: number) =>\n          board[height - coord - 1][lineIdx],\n        setLine: (lineIdx: number) => (coord: number, value: number) => {\n          board[height - coord - 1][lineIdx] = value;\n        },\n        numLines: width,\n        lineLength: height\n      };\n    case 'down':\n      return {\n        getLine: (lineIdx: number) => (coord: number) => {\n          console.log(lineIdx, coord, board);\n          return board[coord][lineIdx];\n        },\n        setLine: (lineIdx: number) => (coord: number, value: number) => {\n          board[coord][lineIdx] = value;\n        },\n        numLines: width,\n        lineLength: height\n      };\n    case 'left':\n      return {\n        getLine: (lineIdx: number) => (coord: number) =>\n          board[lineIdx][width - coord - 1],\n        setLine: (lineIdx: number) => (coord: number, value: number) => {\n          board[lineIdx][width - coord - 1] = value;\n        },\n        numLines: height,\n        lineLength: width\n      };\n    case 'right':\n      return {\n        getLine: (lineIdx: number) => (coord: number) => board[lineIdx][coord],\n        setLine: (lineIdx: number) => (coord: number, value: number) => {\n          board[lineIdx][coord] = value;\n        },\n        numLines: height,\n        lineLength: width\n      };\n  }\n}\n\nexport function propagate(board: Board, shift: BoardShift): boolean {\n  const boardFuncs = getPropagateLineFunc(board, shift);\n  return propagateGrid(\n    boardFuncs.getLine,\n    boardFuncs.setLine,\n    boardFuncs.numLines,\n    boardFuncs.lineLength\n  );\n}\n\nexport function clone(board: Board): Board {\n  return board.map(row => [...row]);\n}\n\nexport function addRandomCell(\n  board: Board,\n  value: number\n): [number, number] | null {\n  let freeCells: [number, number][] = [];\n  const height = getHeight(board);\n  const width = getWidth(board);\n  for (let i = 0; i < width; i++) {\n    for (let j = 0; j < height; j++) {\n      if (board[i][j] === 0) {\n        freeCells.push([i, j]);\n      }\n    }\n  }\n  if (freeCells.length === 0) return null;\n  const randPoint = freeCells[Math.floor(Math.random() * freeCells.length)];\n\n  board[randPoint[0]][randPoint[1]] = value;\n  return [randPoint[0], randPoint[1]];\n}\n\nexport function hasValue(\n  board: Board,\n  fn: (boardVal: number) => boolean\n): boolean {\n  return board.some(row => row.some(cell => fn(cell)));\n}\n\nexport function canMove(board: Board) {\n  const cloneBoard = clone(board);\n  let shifts: BoardShift[] = ['up', 'down', 'left', 'right'];\n  console.log(board);\n  for (let shift of shifts) {\n    if (!propagate(cloneBoard, shift)) {\n      return true;\n    }\n  }\n  return hasValue(cloneBoard, value => value === 0);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAIA;AACA;AAAA;AAAA;AACA;AAEA;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AASA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAFA;AAGA;AACA;AAPA;AACA;AAQA;AACA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAIA;AAAA;AACA;AACA;AAFA;AAGA;AACA;AATA;AACA;AAUA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAFA;AAGA;AACA;AAPA;AACA;AAQA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AAGA;AACA;AANA;AAlCA;AA2CA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;A","sourceRoot":""}